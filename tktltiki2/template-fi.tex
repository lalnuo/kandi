% --- Template for thesis / report with tktltiki2 class ---
% 
% last updated 2013/02/15 for tkltiki2 v1.02

\documentclass[finnish]{tktltiki2}

% tktltiki2 automatically loads babel, so you can simply
% give the language parameter (e.g. finnish, swedish, english, british) as
% a parameter for the class: \documentclass[finnish]{tktltiki2}.
% The information on title and abstract is generated automatically depending on
% the language, see below if you need to change any of these manually.
% 
% Class options:
% - grading                 -- Print labels for grading information on the front page.
% - disablelastpagecounter  -- Disables the automatic generation of page number information
%                              in the abstract. See also \numberofpagesinformation{} command below.
%
% The class also respects the following options of article class:
%   10pt, 11pt, 12pt, final, draft, oneside, twoside,
%   openright, openany, onecolumn, twocolumn, leqno, fleqn
%
% The default font size is 11pt. The paper size used is A4, other sizes are not supported.
%
% rubber: module pdftex

% --- General packages ---

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{microtype}
\usepackage{amsfonts,amsmath,amssymb,amsthm,booktabs,color,enumitem,graphicx}
\usepackage[pdftex,hidelinks]{hyperref}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{amsmath}
\lstset{
	keywordstyle=\color{black}\bfseries, % style for keywords
	numbers=none, % where to put the line-numbers
	numberstyle=\tiny, % the size of the fonts that are used for the line-numbers     
	showspaces=false, % shcow spaces adding particular underscores
	showstringspaces=false, % underline spaces within strings
	showtabs=false, % show tabs within strings adding particular underscores
	frame=single, % adds a frame around the code
	framesep=5pt,
	aboveskip=15pt,
	belowskip=15pt,
	tabsize=2, % sets default tabsize to 2 spaces
	rulesepcolor=\color{gray},
	rulecolor=\color{black},
	captionpos=b, % sets the caption-position to bottom
	breaklines=true, % sets automatic line breaking
	breakatwhitespace=false,
	literate={ö}{{\"o}}1
	{ä}{{\"a}}1
	{ü}{{\"u}}1
}

% Automatically set the PDF metadata fields
\makeatletter
\AtBeginDocument{\hypersetup{pdftitle = {\@title}, pdfauthor = {\@author}}}
\makeatother

% --- Language-related settings ---
%
% these should be modified according to your language

% babelbib for non-english bibliography using bibtex
\usepackage[fixlanguage]{babelbib}
\selectbiblanguage{finnish}

% add bibliography to the table of contents
\usepackage[nottoc]{tocbibind}
% tocbibind renames the bibliography, use the following to change it back
\settocbibname{Lähteet}

% --- Theorem environment definitions ---

\newtheorem{lau}{Lause}
\newtheorem{lem}[lau]{Lemma}
\newtheorem{kor}[lau]{Korollaari}

\theoremstyle{definition}
\newtheorem{maar}[lau]{Määritelmä}
\newtheorem{ong}{Ongelma}
\newtheorem{alg}[lau]{Algoritmi}
\newtheorem{esim}[lau]{Esimerkki}

\theoremstyle{remark}
\newtheorem*{huom}{Huomautus}


% --- tktltiki2 options ---
%
% The following commands define the information used to generate title and
% abstract pages. The following entries should be always specified:

\title{SQL-Injektio ja siltä suojautuminen}
\author{Lalli Nuorteva}
\date{\today}
\level{Kandidaatintutkielma}
\abstract{Tiivistelmä.}

% The following can be used to specify keywords and classification of the paper:

\keywords{avainsana 1, avainsana 2, avainsana 3}

% classification according to ACM Computing Classification System (http://www.acm.org/about/class/)
% This is probably mostly relevant for computer scientists
% uncomment the following; contents of \classification will be printed under the abstract with a title
% "ACM Computing Classification System (CCS):"
% \classification{}

% If the automatic page number counting is not working as desired in your case,
% uncomment the following to manually set the number of pages displayed in the abstract page:
%
% \numberofpagesinformation{16 sivua + 10 sivua liitteissä}
%
% If you are not a computer scientist, you will want to uncomment the following by hand and specify
% your department, faculty and subject by hand:
%
% \faculty{Matemaattis-luonnontieteellinen}
% \department{Tietojenkäsittelytieteen laitos}
% \subject{Tietojenkäsittelytiede}
%
% If you are not from the University of Helsinki, then you will most likely want to set these also:
%
% \university{Helsingin Yliopisto}
% \universitylong{HELSINGIN YLIOPISTO --- HELSINGFORS UNIVERSITET --- UNIVERSITY OF HELSINKI} % displayed on the top of the abstract page
% \city{Helsinki}
%


\begin{document}
	
	% --- Front matter ---
	\frontmatter      % roman page numbering for front matter
	
	\maketitle        % title page
	%\makeabstract     % abstract page
	
	\tableofcontents  % table of contents
	
	% --- Main matter ---
	
	\mainmatter       % clear page, start arabic page numbering
	
	\section{Johdanto}
	Tämän kandidaatintutkielman päätavoite on esitellä selvittää kuinka SQL-injektiolta voidaan suojautua mahdollisimman tehokkaasti. Ensimmäisissä luvuissa esitellään mikä on SQL-injektio. SQL-Injektio esitellään ensin pääpiirteissään. Sen jälkeen esitellään miten se voidaan toteuttaa käytännössä, sekä millaisiin eri alatyyppeihin SQL-injektiot jaotellaan. Kun SQL-Injektion käsite ja lähestymistavat on esitelty, esitellään käytänteet joilla SQL-injektioita pyritään estämään.
	
	Aihe on tärkeä koska verkossa käsitellään jatkuvasti entistä enemmän arkaluontoisia tietoja. Verkossa hoidetaan asioita kuten laskujen maksaminen, hotellien varaus ja henkilökohtaisten viestien vaihtaminen. Yleensä tiedot tallennetaan relaatiotietokantoihin. Juuri tällaiset sovellukset voivat olla haavoittuvaisia SQL-Injektioille, ellei asiaa ole otettu huomioon. Lienee siis itsestäänselvää, että jokaisen tietokantasovelluksia ohjelmoivan on ymmärettävä mikä on SQL-injektio ja kuinka suojautua siltä.
	
	SQL-Injektio on yleisin tietoturva-aukko web-sovelluksissa \cite{detection}. Yleisyytensä lisäksi SQL-injektio on myös hyvin vaarallinen. Onnistuneen SQL-injektion avulla hyökkääjä voi tehdä tietokannalle mitä tahansa operaatioita. SQL-Injektiolla on vuosien aikana tehty lukuisia murtoja. Yksi suurimmista murroista tehtiin SQL-Injektiolla Guess.com:ille. Hyökkääjä sai käsinsä 200 000 ihmisen nimet ja luottokorttitiedot. Sen lisäksi että SQL-injektio on yleisin tietoturva-aukko, se on myös helppoa toteuttaa ilman suurempaa ymmärrystä sen toiminnasta. SQL-Injektioiden tekemiseen löytyy valmiita työkaluja, jotka ilmoittavat sivuston heikkouksista lähes tulkoon napin painalluksella. Tästä esimerkkinä "sqlmap" työkalu joka on tehty tunkeutumistestaamista varten \textit{(engl. penetration testing)}
	
	\section{Käsitteitä}
	-SQL
	- SQL Injection
	out of band
	inband
	\pagebreak
	% Write some science here.
	
	
	
	\section{SQL-Injektio}
	Tavallisesti relaatiotietokantoja käyttävissä sovelluksissa tietokanta on oma erillinen palvelimensa. Sovelluksella on tietokantaan omat tunnuksensa. Sovelluksen tietokantatunnuksien oikeuksia voidaan rajata halutulla tavalla. Esimerkiksi sovelluksen tietokantatunnuksilla on harvoin tarpeellista pystyä poistamaan tietokantatauluja. Sovellus kommunikoi tietokantapalvelimen kanssa käyttäen SQL (\textit{Structured Query Language}) kyselykieltä.
	
	SQL-Injektiossa hyökkääjä pääsee suorittamaan sovelluksen tietokannassa itse kirjoittamiaan käskyjä. Mikäli sovelluksen tietokantakäyttäjän oikeuksia ei ole rajattu, hyökkääjä voi onnistuneen SQL-injektion seurauksena suorittaa mitä tahansa tietokantapalvelimen tukemia SQL-kyselyitä. Tällöin hyökkääjän on mahdollista esimerkiksi lukea, muuttaa, lisätä tai poistaa mitä tahansa tietokannan tietoja. Jotkut tietokantapalvelimet myös sallivat käyttöjärjestelmätason komentojen suorittamisen. Tällöin hyökkääjän on mahdollista suorittaa myös muunlaisia hyökkäyksiä. 
	
	SQL-Injektio on mahdollinen vain silloin kun käyttäjältä tulevaa tietoa käytetään osana tietokantapalvelimelle tehtävää kyselyä. Tämä on kuitenkin varsin tavallinen tarve sovelluksissa. Tietokannassa voidaan säilyttää esimerkiksi käyttäjätunnuksia ja salasanoja. Näin ollen kirjautuessa järjestelmään käyttäjän antamaa syötettä käytetään osana SQL-kyselyä.
	
	\subsection{SQL-Injektio käytännössä}
	
	Anleyn artikkelin "Advancen SQL Injections in SQL Server Applications" mukaan SQL-Injektio hyökkäys esiintyy sillon, kun hyökkääjä pääsee muuttamaan käskyn logiikkaa, semantiikkaa tai syntaksia. Tämä tapahtuu lisäämällä alkuperäiseen kyselyyn uusia SQL-avainsanoja tai operaattoreita \cite{definition}. Esimerkiksi tuotteiden etsimiseen liittyvä sql-käsky voidaan rakentaa sovelluksessa seuraavalla tavalla:
	
	\begin{lstlisting}
	sql = "SELECT * FROM tuotteet
	WHERE nimi ='" + params[:tuotenimi]
	\end{lstlisting}
	
	Mikäli käyttäjä antaa nimekseen "'; DROP TABLE tuottet;'. Valmis kysely tietokannalle näyttää seuraavalta:
	
	\begin{lstlisting}[language=sql]
	sql = "SELECT * FROM tuotteet
	WHERE nimi =''; DROP TABLE tuotteet                             
	\end{lstlisting}
	
	Kyseinen kysely ensin etsii kaikki tuotteet joiden nimi on tyhjä. Seuraavaksi suoritetaan komento "DROP TABLE tuotteet", joka poistaa koko tuotteet taulun.
	
	"DROP TABLE tuotteet"\space tilalla olisi voinut olla mikä tahansa muukin SQL käsky. Esimerkiksi kaikkien tuotteiden listaamiseen hyökkääjä olisi voinut käyttää tuotenimeä joka sisältää jonkin tautologian esimerkiksi "'; OR 1=!". Liittääkseen vastaukseen jonkin muun taulun hyökkääjä olisi voinut käyttää UNION:ia.
	
	\subsection{SQL-Injektion alatyypit}
	Artikkelin "SQL-Injection is still alive"  mukaan SQL-injektioita on kolmea eri päätyyppiä\cite{still-alive}.
	
	\begin{description}
		\item[Inband injektio] \hfill \\
		Kun SQL-injektion tuloste saadaan samaa reittiä kun se on syötetty, on kyseessä inband injektio. Esimerkiksi jos sovelluksessa on mahdollista hakea lista tuotteista jotka ovat maasta jonka käyttäjä antaa kyselyssä.
		
		\item[Out-of-band injektio] \hfill \\
		Kun SQL-Injektion tuloste saadaan eri reittiä kun se on syötetty, on kyseesä out-of-band injektio. Web-sovellus saattaa esimerkiksi tallettaa tietokantaansa millä selaimilla sitä on käytetty. Selaintiedot haetaan HTTP pyynnön "User-Agent" kentästä. Hyökkääjä voi asettaa SQL-injektion User-Agent kenttäänsä. Todennäköisesti hyökkääjä ei näe kyselyn tulosta kyselyn palauttamalla sivulla. Hyökkääjän voi ohjata tulokset itselleen esimerkiksi suorituttamalla injektiossa haun:
		
		\begin{lstlisting}[language=sql]
		utl_http('http://www.hyokkaajansivu.fi/injections/' || 
		SELECT password
		FROM User 
		WHERE username = 'admin'
		)
		\end{lstlisting}
		Injektion onnistuessa hyökkääjän palvelimen logeissa näkyy esimerkiksi:
		
		\begin{lstlisting}
		GET "/injections/admininpassword", 200
		\end{lstlisting}
		
		Tällöin hyökkääjä saa selville käyttäjän admin salasanan.
		
		\item[Sokea injektio] \hfill \\
		Sokea injektio:
		Hyökkääjä ei saa minkäänlaista palautetta sovellukselta. Hyökkääjä voi kuitenkin kokeilla muokata sovelluksen tietoja ja tarkastella vaikuttaako se sovellukseen. Hyökkääjä voi käyttää apunaan sitä kuinka nopeasti sivu latautuu. Lisäämällä injektoituun sql-käskyyn komennon "waitfor delay 0:0:5", tietokanta odottaa 5 sekuntia ennen kuin se palauttaa tuloksen. Tästä voidaan päätellä injektion onnistuneen. \cite{regexp}
		
		
	\end{description}
	
	
	
	\section {Tietoturvallisen ohjelman toteutus}
	SQL-Injektiolta suojautumiseen on kehitetty useita keinoja.  \textit{TÄHÄN TIIVISTELMÄÄ ALLAOLEVISTA YMS}
	

		\subsection{Parametrisoidut kyselyt}
		Parametrisoiduissa kyselyssä luodaan SQL-kyselystä pohja, johon lisätään paikanpitäjät \textit{(engl. placeholder)}. Paikanpitäjät korvataan myöhemmin varsinaisilla arvoilla. Parametrisoitu kysely annetaan tietokannalle. Tietokanta kääntää ja optimoi kyselyn pohjan vain kerran. Tietokanta ei kuitenkaan vielä suorita varsinaista kyselyä, koska varsinaiset arvot puuttuvat. Tällainen toimintatapa parantaa tietoturvan lisäksi myös suorituskykyä.
		
		Parametrisoitujen kyselyiden avulla erotetaan kysely ja siihen liittyvä data. Kun kysely on valmiiksi käännettynä, varsinaisia arvoja ei enää käännetä SQL:läksi. Tästä syystä on mahdotonta, että hyökkääjä voisi suorittaa omia SQL-käskyään syötteensä avulla. Jos hyökkääjä esimerkiksi asettaa käyttäjänimekseen "'OR 1=1'", tietokannasta haetaan käyttäjää jonka käyttäjänimi on "'OR1=1".
		
		Parametrisoidut kyselyt ovat tuettuina lähes kaikissa yleisimmissä ohjelmointikielissä.
		
		\subsection{Korvaaminen}
		Korvaaminen \textit{engl. escaping} on toimenpide jossa käyttäjän syötteestä parsitaan vaaralliset merkit pois. Esimerkiksi ' merkit voidaan muuttaa \textbackslash merkeiksi. Syötteen korvaamisissa on kuitenkin tietokantakohtaisia eroja. Siksi kullekkin tietokannalle on olemassa omat korvaamisfunktionsa. Esimerkiksi PHP:ssa käytetään mySQL:lää varten "my{\_}sql{\_}real{\_}ecape()" funktiota.
		
		\subsection{Datan validointi}
		Datan validointi ei takaa suojaa SQL-injektiolta, mutta se tekee hyökkäyksestä vaikeampaa. Esimerkiksi jos kyseessä on puhelinnumerokenttä, voidaan tarkistaa että syötteessä on vain numeroita. Käytössä voi olla myös luotettujen lista \textit{(engl. whitelist)}, jonne on listattu kaikki syötteelle sallitut arvot.

		\subsection{Arkaluontoisen datan säilytys}
		
		\subsection{Hienojakoinen pääsynhallinta tietokantaan}
		Tämä kappale keskittyy Roichmanin ja Gudesin artikkeliin "Fine-grained Access Control to Web Databases" \cite{access}.\space Ennen web-sovellusten yleistymistä sovelluksia ajettiin käyttäjän omalla tietokoneella. Tyypillisellä sovelluksella oli kiinteä määrä  käyttäjiä. Tällaisessa sovelluskessa sovelluskerros kommunikoi suoraa tietokannan kanssa. Tämän seurauksena tietokanta tietää mikä käyttäjä sitä milloinkin käyttää. Täten on helppoa rajata käyttäjien oikeuksia.
		
		Sen sijaan web-sovelluksissa on tyypillisesti kolme kerrosta. Käyttöliittymänä toimii käyttäjän selain, joka kommunikoi web-sovelluksen palvelimen kanssa. Palvelin välittää käyttäjän käskyt tietokannalle. Tietokannan näkökulmasta komennot antaa web-sovellus, eikä komennon käyttöliittymästä lähettänyt käyttäjä. Täten tietokanta suorittaa sokeasti kaikki saamansa komennot, ellei web-sovellukseen tietokantakäyttäjän oikeuksia ole erikseen rajattu.
		
		Aiemmin esitellyissä menetelmissä on keskitytty ratkaisemaan ongelmaa sovelluskerroksella. Roichmanin ja Gudesin lähestymistavassa keskitytään ratkaisemaan ongelmaa tietokantatasolla parametrisointi metodin \textit{(engl. parameter method)}) avulla. Tekniikka perustuu parametrisoituihin näkymiin \textit{(engl. parametrized views)}. Parametrisoidun näkymän avulla voi suodattaa tallenteita ilman, että tarvitsee tehdä uutta näkymään jokaista eri parametria varten.
		
		\subsubsection {Istuntoon perustuva parametrisointi metodi}
		Sovelluksen tulee ylläpitää tietokantataulua johon merkataan aktiivisten käyttäjien ID:t. Metodi toimii seuraavalla tavalla:
		\begin{enumerate}
			\item Käyttäjä kirjautuu sovellukseen ja sovellus palauttaa käyttäjälle satunnaisen AS\_KEY:n, mikäli kirjautuminen onnistuu.
			
			\item Sovellus tallettaa aktiivisten käyttäjien tauluun käyttäjän ID:n ja sitä vastaavan AS\_KEY:n. Tästä lähin kaikissa käyttäjän tekemissä SQL-kyselyissä käytetään käyttäjäkohtaista AS\_KEY:tä.
			
			\item AS\_KEY poistetaan kun käyttäjä kirjautuu ulos.
		\end{enumerate}
		
		Kirjautumisen jälkeen käyttäjän tiedot ovat taulussa esimerkiksi seuraavalla tavalla:
	
		\begin{center}
		\begin{tabular}{| l | l | l | l |}
			\hline
			KäyttäjäID & AS\_KEY \\ \hline
			\hline
			20 &  01010101.. \\
			\hline
		\end{tabular}
		\end{center}
	

		Nyt voidaan käyttää seuraavanlaista parametrisoitua näkymää:
		\begin{lstlisting}
		CREATE VIEW Palkka_View WITH pAS_KEY
		SELECT * FROM Palkka
		WHERE Kayttaja_ID IN
		(SELECT Kayttaja_ID
		FROM Kayttajat_Table
		WHERE Kayttajat_Table.AS_key=:pAS_KEY) 
		\end{lstlisting}
		Näkymä ottaa parametrina AS\_Key:n, jonka käyttäjä on saanut kirjautuessaan. Käyttäjän kyselyt tehdään näkymään "Palkka\_View"\space eikä tauluun "Palkka". Mikäli hyökkääjä yrittäisi tehdä SQL-injektion tautologian avulla, suoritettava kysely näyttäisi seuraavalta:
		\begin{lstlisting}
			SELECT Palkka
			FROM Palkka_View(01010101..) 
			WHERE Palkka_pvm  = '12/2015' OR 1=1
		\end{lstlisting}
		Hyökkääjä saisi vastauksena kaikki omat palkkatietonsa, mutta ei muiden käyttäjien, koska Palkka\_View saa saa parametriksi hyökkääjän oman AS\_KEY:n. Myöskään UNION injektio ei ole tässä tapauksessa mahdollinen, koska hyökkääjä ei tiedä muiden käyttäjien AS\_KEY:tä, joka tarvitaan Palkka\_Viewiin parametriksi.
	
	\subsection{AMNESIA Menetelmä}
	
	Halfonding ja Orson artikkelissa \cite{amnesia} esitellään SQL-injektioiden torjumiseksi AMNESIA tekniikkaa. AMNESIA on lyhenne sanoille "Analysis and Monitoring for NEutralizing SQL-Injection Attacks". Tekniikka koostuu neljästä osasta.
	\begin{enumerate}
		\item{Etsi suorituspaikat}
		
		Ensin ohjelman koodi skannataan. Skannauksessa etsitään koodista ne paikat, joissa tietokantakyselyjä suoritetaan. Näihin paikkoihin viitataan tässä tutkielmassa sanalla "suorituspaikka" \textit{(engl. hotspot)}. Esimerkiksi Javan tapauksessa etsitään koodista paikat joissa kutsutaan "java.sql.Statement.execute(String)" \space metodia.
		\item{Rakenna SQL-kyselymallit}
		
		Seuraavaksi rakennetaan jokaiselle edellisessä kohdassa löydetylle suorituspaikalle oma mallinsa. Tämä onnistuu siten, että AMNESIA simuloi sovelluksen toimintaa Java String Analysis (JSA) kirjaston avulla. JSA Luo analyysin tuloksena epädetermistisen ääreellisen automaatin (NDFA), joka tunnistaa kaikki mahdolliset merkkijonot, jotka kysely voi saada arvokseen. Esimerkiksi allaoleva koodipätkä voi saada arvokseen joko: 
		"SELECT info FROM kayttajat WHERE kayttajanimi = $\beta$"\space tai "SELECT info FROM kayttajat WHERE kayttajanimi='vieras'". Käyttäjän syötettä merkataan symbolilla $\beta$.
		
		\begin{lstlisting}
		query = "SELECT info FROM users WHERE"
		if (!kayttajanimi.empty) {
		query += "kayttajanimi ='" + kayttajanimi + "'"
		} else {
		query += "kayttajanimi = vieras"
		}
		\end{lstlisting}
		
		
		\item{Instrument application}
		
		Seuraavaksi lisätään jokaiseen vaiheessa 1. löydettyyn suorituspaikkaan monitori. Monitori suoritetaan aina ennen itse tietokantakyselyä. Monitori ottaa parametriksi suorituspaikan uniikin ID:n ja merkkijonon jota ollaan suorittamassa. ID:n avulla monitori etsii kyseistä suorituspaikkaa vastaavan mallin. Alla sama koodi esimerkkinä: 
		\begin{lstlisting}
		if (monitor.hyvaksyy(<suortuspaikan id>, kysely)) {
		return db.suorita(kysely);
		}
		\end{lstlisting}
		\item{Ajonaikainen monitorointi}
		
		Ajonaikana ohjelma toimii normalisti kunnes se törmää suorituspaikkaan. Suorituspaikkaan törmättyään se antaa tarvittavat parametrit monitorille. Ensin monitori käsittelee kyselyn samalla tapaa kuin tietokanta sen käsittelisi. Tämän asiosta esimerkiksi erikoismerkit evaluoituvat niiden oikeaan arvoonsa. Tämä estää SQL-avainsanojen piilottamisen erikoismerkeillä. Kun kysely on käsitelty, tarkastetaan tunnistaako malli sen. Mikäli malli hyväksyy kyselyn se suoritetaan, muulloin malli tunnistaa sen SQL-injektioksi.
		
		Oletetaan että kyselymme olisi "SELECT info FROM users WHERE kayttajanimi='' OR 1=1. Vaiheessa 1. kuvatun koodipätkän automaatti jakautuisi kahtia. Koska automaatti tunnistaa vain kielet jotka loppuvat merkkiin "'", kyseinen kysely huomataan SQL-injektioksi.
		
		[tähän äskösen automaattikuva]
	\end{enumerate}
	
	\section{Ohjelmiston testaus SQL-injektioiden varalta}
	
	 Vaikka sovellusta ohjelmoitaisiin edellisen kappaleen neuvojen mukaisesti, siihen voi silti jäädä tietoturva-aukkoja. Tämän takia sovellusta on tietoturvatestattava. Penetraatiotestauksessa yritetään etsiä sovelluksesta tietoturva-aukkoja. Kun penetraatiotestaus on automatisoitua, ohjelmoijan ei tarvitse käsin testata järjestelmäänsä jokaisen muutoksen jälkeen. Automatisoitu testauskaan ei ole virheetöntä, sillä se voi aiheuttaa turhia hälyytyksiä, tai olla hälyyttämättä kun pitäisi hälyyttää \cite{virheita}. 
	
	 Penetraatiotestaus voidaan jakaa valkolaatikko- \textit{(engl. white-box testing)} ja musta laatikko -testaukseen \textit{(engl. black-box testing)}. Musta laatikko -testauksessa ei päästä käsiksi ohjelman koodiin. Ohjelmalle annetaan erilaisia syötteitä ja tutkitaan tulostetta. Tulosteesta päätellään tässä tapauksessa onko SQL-injektio tapahtunut vai ei. Valkolaatikko testauksessa sen sijaan testataan ohjelman sisäisiä struktuureja.
	
	\subsubsection{Musta laatikko -testaus}
	 Haixia edottaa artikkelissaan "A database security testing scheme of web application" \cite{testing} seuraavanlaista testausmallia.
	
	Ensiksi etsitään kaikki mahdolliset paikat sovelluksesta, joista käyttäjä voi syöttää dataa. Tämä onnistuu leveyssuuntaista hakua (\textit{engl. Breadth-first search}) käyttämällä. Algoritmi toimii seuraavasti:
	\begin{enumerate}
		\item Alustetaan lista L jossa on ainoana jäsenenä etusivun URL. Etusivu merkataan käsittelemättökäks.
		
		\item Käydään listalta L läpi kaikki käsittelemättömiksi merkatut sivut ja merkataan ne käsitellyiksi. Jokaiselta sivulta kirjataan kaikki paikat joista käyttäjä voi syöttää dataa. Lopuksi etsitään sivulta kaikki linkit. Ne linkit jotka eivät vielä ole listalla L, lisätään listalle.
		
		\item Mikäli listalla on käsittelemättömiä linkkejä, palataan vaiheeseen 2.
	\end{enumerate}
	
	Tämän jälkeen luodaan mahdollisimman kattava lista erilaisista haitallisista syötteistä. Kaikkiin mahdollisiin paikkoihin joista voi syöttää dataa sisään kokeillaan kaikkia haitallisia syötteitä. Tietokannan palauttamasta arvosta voidaan päätellä onko injektio onnistunut vai ei. Esimerkiksi jos vastauksen HTTP statuskoodi on 200, kyseessä on haavoittuvuus.
	
	Mustalaatikkotestaukseen löytyy useita valmiita työkaluja, kuten "Acunetix Web Vulnerability Scanner" ja sqlmap.
	
	\subsubsection{Valkolaatikkotestaus}
	- static code analyzers
	
	\pagebreak
	
	\pagebreak
	\section {Yhteenveto}
	- yksinkertaista suojauta
	- kuitenkin muitakin riskejä kuten xss yms.
	- 

	
	
	
	
	% --- References ---
	%
	% bibtex is used to generate the bibliography. The babplain style
	% will generate numeric references (e.g. [1]) appropriate for theoretical
	% computer science. If you need alphanumeric references (e.g [Tur90]), use
	%
	% \bibliographystyle{babalpha-lf}
	%
	% instead.
	
	\bibliographystyle{babplain-lf}
	\bibliography{references-fi}
	
	
	% --- Appendices ---
	
	% uncomment the following
	
	% \newpage
	% \appendix
	% 
	% \section{Esimerkkiliite}
	
\end{document}